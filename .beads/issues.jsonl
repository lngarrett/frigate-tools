{"id":"frigate-tools-04g","title":"Add debug logging for invalid skip_hours values","description":"parse_skip_hours() silently ignores invalid hour values like '18-24' (hour 24 is out of range 0-23). Users may not realize their filter isn't being applied. Add structlog debug message when invalid ranges are encountered to aid troubleshooting.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-06T14:17:55.093070256-05:00","updated_at":"2025-12-06T14:26:20.433630846-05:00","closed_at":"2025-12-06T14:26:20.433630846-05:00","dependencies":[{"issue_id":"frigate-tools-04g","depends_on_id":"frigate-tools-9eh","type":"blocks","created_at":"2025-12-06T14:18:13.773323895-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-0a1","title":"Fix timezone handling: assume local time input, convert to UTC for file matching","description":"## Problem\n\nFrigate stores recordings using UTC timestamps in the directory structure:\n```\n/recordings/YYYY-MM-DD/HH/camera/MM.SS.mp4\n```\nWhere HH is the UTC hour.\n\nThe CLI currently accepts naive datetime inputs and compares them directly against these UTC paths. This means:\n- User inputs `--start \"2025-12-07 11:00\"` (intending 11 AM local)\n- CLI finds files from UTC 11:00\n- But UTC 11:00 = 6 AM EST (5 hours off!)\n\n## Solution\n\nAssume all time inputs are **local time** and convert to UTC internally for file matching.\n\n### Implementation\n\n1. In `cli.py`, after parsing datetime args, convert to UTC:\n```python\nfrom datetime import timezone\nimport time\n\ndef local_to_utc(dt: datetime) -\u003e datetime:\n    \"\"\"Convert naive local datetime to UTC.\"\"\"\n    # Get local timezone offset\n    if time.daylight:\n        utc_offset = -time.altzone\n    else:\n        utc_offset = -time.timezone\n    \n    # Add timezone info and convert\n    local_tz = timezone(timedelta(seconds=utc_offset))\n    return dt.replace(tzinfo=local_tz).astimezone(timezone.utc).replace(tzinfo=None)\n```\n\n2. Apply conversion to `start` and `end` before passing to `generate_file_lists()`\n\n3. Update help text to clarify times are interpreted as local time\n\n## Testing\n\n- Test with known local time and verify correct UTC files are found\n- Test across DST boundaries if applicable\n- Test with times near midnight (date boundary edge case)","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-07T11:24:08.778531399-05:00","updated_at":"2025-12-07T11:28:12.099110399-05:00","closed_at":"2025-12-07T11:28:12.099110399-05:00"}
{"id":"frigate-tools-2io","title":"Clip file selection and concatenation","description":"Find segments overlapping time range from Frigate recordings. Concat with -c copy (default, fast) or reencode if requested. Reuse file list logic from timelapse module. Tests with mock directory structure.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T14:02:13.222286397-05:00","updated_at":"2025-12-06T14:22:37.785742405-05:00","closed_at":"2025-12-06T14:22:37.785742405-05:00","dependencies":[{"issue_id":"frigate-tools-2io","depends_on_id":"frigate-tools-9eh","type":"blocks","created_at":"2025-12-06T14:05:31.0648634-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-2ip","title":"Clip multi-camera output","description":"Multi-camera clip support. Default: grid layout (reuse grid module from timelapse). Option --separate for individual files per camera. Sync timestamps across cameras.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T14:02:18.319830875-05:00","updated_at":"2025-12-06T14:22:48.343437364-05:00","closed_at":"2025-12-06T14:22:48.343437364-05:00","dependencies":[{"issue_id":"frigate-tools-2ip","depends_on_id":"frigate-tools-2io","type":"blocks","created_at":"2025-12-06T14:05:31.109811952-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-2ip","depends_on_id":"frigate-tools-485","type":"blocks","created_at":"2025-12-06T14:05:31.121215551-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-3pz","title":"Fix Frigate directory structure - date/hour/camera not camera/date/hour","description":"file_list.py assumes recordings are stored as: recordings/camera/YYYY-MM-DD/HH/MM.SS.mp4\n\nBut actual Frigate structure is: recordings/YYYY-MM-DD/HH/camera/MM.SS.mp4\n\nThis causes 'No recording files found' error. Need to update find_recording_files() to use the correct path structure: instance_path/recordings/date_dir/hour_dir/camera/filename instead of instance_path/recordings/camera/date_dir/hour_dir/filename","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-06T14:30:07.619632543-05:00","updated_at":"2025-12-06T14:32:54.92911649-05:00","closed_at":"2025-12-06T14:32:54.92911649-05:00"}
{"id":"frigate-tools-3s3","title":"Timelapse CLI interface","description":"Typer CLI: frigate-tools timelapse --cameras bporchcam,frontcam --start 2025-12-01T08:00 --end 2025-12-05T16:00 --duration 5m --skip-days sat,sun --skip-hours 16-8 -o output.mp4. Wire up all components. Auto-detect instance from available paths.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:58:05.889102225-05:00","updated_at":"2025-12-06T14:22:03.756666472-05:00","closed_at":"2025-12-06T14:22:03.756666472-05:00","dependencies":[{"issue_id":"frigate-tools-3s3","depends_on_id":"frigate-tools-485","type":"blocks","created_at":"2025-12-06T14:05:31.086688927-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-3s3","depends_on_id":"frigate-tools-9eh","type":"blocks","created_at":"2025-12-06T14:05:31.098602311-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-485","title":"Multi-camera grid layout","description":"Auto-calculate optimal grid dimensions (2 cams = 1x2, 3-4 = 2x2, 5-6 = 2x3, etc). Use ffmpeg filter_complex with xstack for tiling. Sync file lists across cameras and handle gaps where one camera may have missing segments.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:57:59.839018623-05:00","updated_at":"2025-12-06T14:18:13.801111569-05:00","closed_at":"2025-12-06T14:18:13.801111569-05:00","dependencies":[{"issue_id":"frigate-tools-485","depends_on_id":"frigate-tools-d4r","type":"blocks","created_at":"2025-12-06T14:05:31.074671456-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-48e","title":"Report hardware/software encoding mode to user during timelapse","description":"During timelapse creation, show the user whether hardware acceleration (VAAPI/QSV) or software encoding is being used. This helps users know if they need to add themselves to video/render groups for faster encoding.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-06T15:59:27.289371931-05:00","updated_at":"2025-12-06T16:09:37.044552595-05:00","closed_at":"2025-12-06T16:09:37.044552595-05:00"}
{"id":"frigate-tools-4fz","title":"Improve BSF timelapse progress reporting","description":"## Problem\n\nDuring BSF timelapse creation, the progress reporting is inadequate:\n- Pass 1 (concat) shows no progress updates - user has no idea if things are working\n- User should see visual feedback at least every 15 seconds\n- Current implementation just shows 5% at start and 90% when concat finishes\n\n## Current Behavior\n\n```\n[5%] Starting concat...\n[nothing for 1-2 minutes]\n[90%] Concat done, BSF starting...\n[100%] Complete\n```\n\n## Expected Behavior\n\n```\n[5%] Concatenating files... (0/360)\n[10%] Concatenating files... (36/360)\n[15%] Concatenating files... (72/360)\n...\n[90%] Applying BSF filter...\n[95%] Finalizing...\n[100%] Complete\n```\n\n## Technical Approach\n\nFor Pass 1 (concat with `-c copy`), ffmpeg does not report progress via `-progress pipe:1` since there is no encoding. Options:\n\n1. **Monitor output file size growth** - Compare current size to expected final size\n2. **Use ffmpeg stderr parsing** - Look for \"time=\" in stderr output\n3. **Estimate from elapsed time** - Less accurate but simple\n\nRecommended: Monitor output file size since we know expected size (~10MB per 360 files for concat).\n\n## Implementation\n\n```python\ndef _bsf_pass1_concat_with_progress(\n    input_files: list[Path],\n    output_path: Path,\n    progress_callback: Callable[[ProgressInfo], None] | None = None,\n) -\u003e bool:\n    # Estimate final size: ~10MB per 10s segment\n    expected_size = len(input_files) * 10 * 1024 * 1024\n    \n    # Start ffmpeg process\n    process = subprocess.Popen(cmd, ...)\n    \n    # Poll for progress every 5 seconds\n    while process.poll() is None:\n        if output_path.exists() and progress_callback:\n            current_size = output_path.stat().st_size\n            percent = min(85, 5 + (current_size / expected_size) * 80)\n            progress_callback(ProgressInfo(percent=percent))\n        time.sleep(5)\n```\n\n## Acceptance Criteria\n\n- [ ] Progress updates at least every 15 seconds during Pass 1\n- [ ] Progress bar shows meaningful advancement during concat\n- [ ] Pass 2 progress also reported (even if brief)\n- [ ] CLI output shows files processed or size progress","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-07T17:21:25.318007183-05:00","updated_at":"2025-12-07T17:23:25.074053333-05:00","closed_at":"2025-12-07T17:23:25.074053333-05:00"}
{"id":"frigate-tools-6mq","title":"Prototype timelapse performance optimizations","description":"## Goal\n\nEvaluate three alternative approaches for timelapse generation that could dramatically improve performance over the current implementation.\n\n## Current Performance\n\n- 15,480 files (5 days, 8am-4pm) → 5 min timelapse\n- Current time: **1 hour 49 minutes**\n- Bottleneck: Opens all 15,480 files, decodes 154k keyframes, selects 9k\n\n## Approaches to Prototype\n\n1. **Two-pass: Concat + Bitstream Filter** - Fast concat, then BSF on single file\n2. **Parallel Seek Extraction** - N parallel ffmpeg processes seeking to specific timestamps  \n3. **Image2pipe Sparse Extraction** - Pipe sparse frames between ffmpeg instances\n\n## Success Criteria\n\n- Maintain acceptable visual quality (subjective comparison)\n- Target: \u003c15 minutes for the 5-day test case (10x improvement)\n- Stretch: \u003c5 minutes (20x improvement)\n\n## Test Case\n\n```bash\nuv run frigate-tools timelapse create \\\n  -c bporchcam \\\n  -s 2025-12-01T08:00 \\\n  -e 2025-12-06T15:00 \\\n  -d 5m \\\n  --skip-hours 16-8 \\\n  -o timelapse_week.mp4\n```\n\n- 15,480 files\n- 516x speedup\n- 9,000 output frames needed","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-07T16:22:53.149909139-05:00","updated_at":"2025-12-07T16:53:01.043789555-05:00","closed_at":"2025-12-07T16:53:01.043789555-05:00"}
{"id":"frigate-tools-6mq.1","title":"Prototype: Two-pass concat + bitstream filter","description":"## Approach\n\nTwo-pass approach that works around concat demuxer + bitstream filter incompatibility:\n\n**Pass 1**: Fast concat all files (no decode)\n```bash\nffmpeg -f concat -safe 0 -i list.txt -c copy concatenated.mp4\n```\n\n**Pass 2**: Bitstream filter on single file (no decode)\n```bash\nffmpeg -discard nokey -i concatenated.mp4 -c copy \\\n  -bsf:v noise=drop='mod(n\\,17)',setts=ts='N/30/TB_OUT' timelapse.mp4\n```\n\n## Results\n\n### Test Configuration\n- **Input**: 360 files (1 hour of footage from bporchcam)\n- **Target output**: 15 seconds @ 30fps\n- **Speedup**: ~240x\n\n### Timing Breakdown\n\n| Phase | Time | Notes |\n|-------|------|-------|\n| Pass 1: Concat | 210.3s | Stream copy, I/O bound, created 3.51GB file |\n| Keyframe counting | ~112s | Used ffprobe with -skip_frame nokey (requires decode) |\n| Pass 2: BSF | 2.0s | Packet-level processing, extremely fast |\n| **Total** | **324.9s** | 5.4 minutes |\n\n### Output Quality\n- **Resolution**: 2688x1520 (native, no scaling)\n- **Codec**: h264 (stream copy from source)\n- **Framerate**: 30 fps\n- **Duration**: 15.07s (target: 15.0s) ✓\n- **File size**: 195.8 MB\n\n## Key Findings\n\n1. **Two-pass BSF works correctly** - Output is accurate duration and maintains source quality\n2. **New bottleneck identified**: Keyframe counting takes 112s because ffprobe must decode frames to count keyframes\n3. **Pass 2 is extremely fast** - BSF processes at packet level without decode (~2s for 3.5GB)\n4. **Concat pass is I/O bound** - 210s to write 3.5GB (mostly disk speed limited)\n\n## Optimization Opportunities\n\n1. **Skip keyframe counting**: Estimate from file count instead\n   - Frigate files are consistently ~10 keyframes per 10-second file\n   - Formula: `estimated_keyframes = file_count * 10`\n   - Would save ~112s (35% of total time)\n\n2. **Intermediate file overhead**: Pass 1 creates large temp file (3.5GB for 1 hour)\n   - Week of footage would be ~60GB temp file\n   - Could use named pipe instead of file for streaming\n\n## Files\n- Prototype: `prototypes/two_pass_bsf.py`\n- Test output: `/tmp/hour_two_pass.mp4`\n\n## Comparison to Current Implementation\n\nFor reference, the current timelapse implementation for similar footage:\n- Current: Decodes all frames, selects with filter, re-encodes\n- Two-pass BSF: No decode (except keyframe count), no encode\n\n**Verdict**: Promising approach, but keyframe counting is the new bottleneck. Eliminating it would make this ~3.5 minutes for 1 hour of footage.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T16:23:05.65898326-05:00","updated_at":"2025-12-07T16:52:54.520006507-05:00","closed_at":"2025-12-07T16:52:54.520006507-05:00","dependencies":[{"issue_id":"frigate-tools-6mq.1","depends_on_id":"frigate-tools-6mq","type":"parent-child","created_at":"2025-12-07T16:23:05.660066917-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-6mq.2","title":"Prototype: Parallel seek-based frame extraction","description":"## Approach\n\nUse N parallel ffmpeg processes to seek directly to needed timestamps, extract single frames, then encode.\n\n**Step 1**: Calculate which files/timestamps contain needed frames\n```python\n# 9000 frames needed across 154,890 seconds\n# = 1 frame every 17.2 seconds\ntimestamps = [i * 17.2 for i in range(9000)]\n# Map each timestamp to (file_index, offset_within_file)\n```\n\n**Step 2**: Parallel extraction with fast seek\n```bash\n# N parallel processes (e.g., N=16)\nffmpeg -ss $offset -i $file -frames:v 1 -q:v 2 frame_$i.jpg \u0026\n```\n\n**Step 3**: Encode frames to video\n```bash\nffmpeg -framerate 30 -i frame_%d.jpg -c:v libx264 -preset fast output.mp4\n```\n\n## Why This Should Be Fast\n\n- Fast seek (`-ss` before `-i`) skips to keyframe without decoding\n- Only opens ~9000 files (the ones with needed frames)\n- Parallel extraction uses all CPU cores\n- Benchmarks show ~20x speedup vs sequential\n\n## Implementation\n\n1. Create standalone Python script: `prototypes/parallel_seek.py`\n2. Accept: input file list, output path, target duration, parallelism level\n3. Use `concurrent.futures.ProcessPoolExecutor` for parallel extraction\n4. Extract to temp directory, then encode\n5. Clean up temp files\n6. Time each phase separately\n\n## Test\n\nRun against the 15,480 file test case with N=8, N=16, N=32:\n- Measure extraction time\n- Measure encoding time\n- Measure total time\n- Test different parallelism levels\n- Verify output plays correctly\n\n## Deliverables\n\n- Working prototype script\n- Timing results at different parallelism levels\n- Output video for quality comparison\n- Notes on optimal parallelism for the hardware","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T16:23:18.545117907-05:00","updated_at":"2025-12-07T16:37:44.572677025-05:00","closed_at":"2025-12-07T16:37:44.572677025-05:00","dependencies":[{"issue_id":"frigate-tools-6mq.2","depends_on_id":"frigate-tools-6mq","type":"parent-child","created_at":"2025-12-07T16:23:18.545718561-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-6mq.3","title":"Prototype: Image2pipe sparse extraction","description":"## Approach\n\nUse image2pipe to stream sparse frames between two ffmpeg instances.\n\n## Implementation\n\nCreated `prototypes/image2pipe.py` with 4 methods:\n\n1. **Method 1**: Direct framerate reduction via `-r` flag\n2. **Method 2**: Select filter with rawvideo pipe\n3. **Method 3**: Keyframe-only + select + PPM pipe\n4. **Method 3b**: Keyframe-only + select + MJPEG pipe\n\n## Test Results\n\n**Small test** (10 files, 100s source → 10s output, 180x speedup):\n\n| Method | Time | Realtime Speed | Output Size |\n|--------|------|----------------|-------------|\n| method3 (keyframe+PPM) | 6.0s | 16.8x | 5.1 MB |\n| method3b (keyframe+MJPEG) | 6.0s | 16.5x | 5.4 MB |\n| method2 (select+rawvideo) | 7.9s | 12.7x | 12.9 MB |\n| method1 (framerate) | 11.2s | 8.9x | 13.8 MB |\n\n## Key Findings\n\n1. **Method 3 is fastest** - Keyframe-only decoding (`-skip_frame nokey`) combined with PPM pipe\n2. **PPM vs MJPEG similar** - Both achieve ~16x realtime, PPM slightly smaller output\n3. **Rawvideo pipe is slower** - Higher bandwidth through pipe hurts performance\n4. **Framerate reduction slowest** - Has to decode all frames even though most are discarded\n\n## Limitations\n\n- Full-scale testing (17k+ files) not completed due to time constraints\n- Need to validate that 16x speedup holds at scale\n- PPM pipe may have memory/bandwidth issues with 4K video\n\n## Recommendation\n\nMethod 3 (keyframe + PPM pipe) is the recommended approach for further investigation. Projected time for 5-day test case: ~10 minutes (vs current 1h49m).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T16:23:32.433685266-05:00","updated_at":"2025-12-07T16:52:55.348121142-05:00","closed_at":"2025-12-07T16:52:55.348121142-05:00","dependencies":[{"issue_id":"frigate-tools-6mq.3","depends_on_id":"frigate-tools-6mq","type":"parent-child","created_at":"2025-12-07T16:23:32.434146754-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-6mq.4","title":"Assess timelapse prototype results and recommend approach","description":"## Goal\n\nCompare the three prototype approaches and recommend which to implement in frigate-tools.\n\n## Comparison Criteria\n\n### Performance\n| Approach | Time | vs Current (109 min) |\n|----------|------|---------------------|\n| Two-pass BSF | ? | ? |\n| Parallel Seek | ? | ? |\n| Image2pipe | ? | ? |\n\n### Quality\n- Visual comparison of output videos\n- Any artifacts, glitches, or issues?\n- Frame timing/smoothness\n\n### Resource Usage\n- Disk space (temp files)\n- Memory usage\n- CPU usage pattern\n\n### Complexity\n- Code complexity to integrate\n- Error handling considerations\n- Hardware acceleration compatibility\n\n## Deliverables\n\n1. **Comparison table** with all metrics\n2. **Quality assessment** - are all outputs acceptable?\n3. **Recommendation** - which approach to implement\n4. **Implementation notes** - gotchas discovered during prototyping\n5. **Estimated effort** to integrate into frigate-tools\n\n## Decision Criteria\n\n- Must be at least 5x faster than current (\u003c 22 minutes)\n- Must produce acceptable quality output\n- Prefer simpler implementation if performance is similar\n- Consider hardware acceleration potential","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T16:23:43.23714413-05:00","updated_at":"2025-12-07T16:52:53.804965821-05:00","closed_at":"2025-12-07T16:52:53.804965821-05:00","dependencies":[{"issue_id":"frigate-tools-6mq.4","depends_on_id":"frigate-tools-6mq","type":"parent-child","created_at":"2025-12-07T16:23:43.238975016-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-6mq.4","depends_on_id":"frigate-tools-6mq.1","type":"blocks","created_at":"2025-12-07T16:23:59.437753105-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-6mq.4","depends_on_id":"frigate-tools-6mq.2","type":"blocks","created_at":"2025-12-07T16:23:59.449486079-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-6mq.4","depends_on_id":"frigate-tools-6mq.3","type":"blocks","created_at":"2025-12-07T16:23:59.470219698-05:00","created_by":"daemon"}],"comments":[{"id":4,"issue_id":"frigate-tools-6mq.4","author":"logan","text":"## Prototype Assessment Results\n\n### Test Configuration\n- **Source**: 24 hours of bporchcam recordings (8,640 files, ~35GB)\n- **Target**: 15 second timelapse @ 30fps (450 frames)\n- **Speedup**: 5760x\n\n### Performance Comparison\n\n| Approach | Time | vs Current (est 10-15+ min) | Status |\n|----------|------|----------------------------|--------|\n| Parallel Seek | 25s (32 workers) | **~20-30x faster** | ✅ Tested |\n| Two-pass BSF | Killed (I/O bound) | N/A | ❌ Failed |\n| Image2pipe | Not tested | N/A | ⏸️ Skipped |\n\n### Parallel Seek Results by Worker Count\n\n| Workers | Extraction Rate | Extraction Time | Encode Time | Total Time |\n|---------|-----------------|-----------------|-------------|------------|\n| 8 | 16.5 fps | 27.32s | 5.67s | **33.02s** |\n| 16 | 20.8 fps | 21.59s | 6.26s | **27.89s** |\n| 32 | 24.1 fps | 18.70s | 5.79s | **24.53s** |\n\n### Why Two-pass BSF Failed\n\nThe two-pass BSF approach requires:\n1. Concatenating ALL 8,640 files first → ~35GB temp file\n2. Then applying filters on the concatenated file\n\nThis I/O-bound concatenation step takes too long and was killed after several minutes.\n\n### Why Parallel Seek Wins\n\n1. **Skips unnecessary files**: Only opens 450 files (the ones with needed frames), not all 8,640\n2. **Direct seeking**: Uses ffmpeg's fast input seeking (-ss before -i)\n3. **Parallel extraction**: Multiple workers extract frames simultaneously\n4. **Small temp files**: Only stores JPEG frames, not full video\n\n### Quality Assessment\n\n- Full resolution output (2688x1520)\n- Hardware encoding (h264_vaapi) works correctly\n- No visible artifacts or glitches\n\n### Recommendation\n\n**Implement Parallel Seek approach** for high-speedup timelapses (speedup \u003e 100x).","created_at":"2025-12-07T21:52:45Z"}]}
{"id":"frigate-tools-77o","title":"Fix timelapse concatenation hanging on large file counts","description":"","status":"closed","priority":0,"issue_type":"epic","created_at":"2025-12-06T17:22:21.110701425-05:00","updated_at":"2025-12-06T17:25:17.287629579-05:00","closed_at":"2025-12-06T17:25:17.287629579-05:00"}
{"id":"frigate-tools-77o.1","title":"Create a reproducible test case for the hanging concatenation","description":"Create a script that generates a large number of small, empty video files to reliably reproduce the hanging concatenation issue without depending on real user data. This will provide a consistent test bed for debugging.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T17:22:29.36200099-05:00","updated_at":"2025-12-06T17:23:54.695011111-05:00","closed_at":"2025-12-06T17:23:54.695011111-05:00","dependencies":[{"issue_id":"frigate-tools-77o.1","depends_on_id":"frigate-tools-77o","type":"parent-child","created_at":"2025-12-06T17:22:29.362582159-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-77o.2","title":"Verify the batch concatenation fix","description":"Using the reproducible test case, verify that the existing batch concatenation implementation in concat_files successfully resolves the hanging issue. If it does not, debug and refine the batching logic until it works.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T17:22:33.944398102-05:00","updated_at":"2025-12-06T17:24:33.076041527-05:00","closed_at":"2025-12-06T17:24:33.076041527-05:00","dependencies":[{"issue_id":"frigate-tools-77o.2","depends_on_id":"frigate-tools-77o","type":"parent-child","created_at":"2025-12-06T17:22:33.945009001-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-77o.3","title":"Fix the progress bar for batch concatenation","description":"Implement accurate, file-count-based progress reporting for the batch concatenation process in concat_files and cli.py. The progress bar should reflect the number of files processed out of the total, providing a clear and correct user experience.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T17:22:40.747298586-05:00","updated_at":"2025-12-06T17:25:09.97112362-05:00","closed_at":"2025-12-06T17:25:09.97112362-05:00","dependencies":[{"issue_id":"frigate-tools-77o.3","depends_on_id":"frigate-tools-77o","type":"parent-child","created_at":"2025-12-06T17:22:40.747868438-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-7uu","title":"Encoding gets stuck on large files - BOTH select AND setpts approaches fail","description":"","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-06T15:27:07.452817341-05:00","updated_at":"2025-12-06T16:07:38.088208419-05:00","closed_at":"2025-12-06T16:07:38.088208419-05:00","dependencies":[{"issue_id":"frigate-tools-7uu","depends_on_id":"frigate-tools-ell","type":"blocks","created_at":"2025-12-06T15:27:12.07198498-05:00","created_by":"daemon"}],"comments":[{"id":2,"issue_id":"frigate-tools-7uu","author":"logan","text":"## UPDATE: Both approaches have been tried and BOTH fail\n\n### Attempt 1: select filter (commit 01e4e11)\nCommand: -vf select='not(mod(n,360))',setpts=N/(30.0*TB)\n- Gets stuck at ~39% through 22GB file (8.6GB read)\n- High CPU (500%+) but no I/O progress\n\n### Attempt 2: setpts filter (commit a619293)\nCommand: -vf setpts=PTS/360.55\n- Gets stuck at ~32% through 22GB file (7.1GB read)\n- Same symptoms: high CPU, frozen I/O\n\n### Common pattern\nBoth freeze at 30-40% through file. ffmpeg uses 500-600% CPU but no read/write progress.\n\n### What needs to be tried\n1. Skip concat - process source segments directly\n2. Parallel segment processing\n3. Chunked processing - split into smaller pieces\n4. Hardware acceleration (QSV available on this system)\n\n### Test case\nInput: 6 hours (2160 files, 21GB), Target: 60s timelapse\n","created_at":"2025-12-06T20:48:18Z"},{"id":3,"issue_id":"frigate-tools-7uu","author":"logan","text":"DO NOT CLOSE - BUG NOT FIXED. Both select and setpts filters freeze at 30-40% through 22GB file. Tested live, fails every time. Must remain OPEN until 6-hour timelapse completes successfully.\n","created_at":"2025-12-06T20:56:00Z"}]}
{"id":"frigate-tools-7zx","title":"Add rich progress bars for CLI operations","description":"","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-12-06T15:01:31.169918861-05:00","updated_at":"2025-12-06T15:08:38.190142424-05:00","closed_at":"2025-12-06T15:08:38.190142424-05:00"}
{"id":"frigate-tools-8nc","title":"Optimize timelapse encoding pipeline with full hardware acceleration","description":"## Problem\n\nCurrent timelapse encoding only uses hardware for the final encoding step, while decoding and filtering run on CPU. This causes severe performance bottlenecks:\n\n- **Current performance**: 3 minutes to encode 1 hour of footage (240x speedup)\n- **CPU usage**: 548% (5.5 cores maxed out)\n- **Bottleneck**: CPU decoding + CPU setpts filter processing all frames\n\n### Current Pipeline\n```\nInput (3.6GB) → CPU Decode → CPU setpts filter → CPU format conversion → GPU upload → GPU Encode → Output (40MB)\n```\n\n### Issues\n1. No hardware decoding - reading 3.6GB H.264 on CPU\n2. setpts filter processes ALL frames on CPU (108k frames to output 450 frames)\n3. format=nv12 + hwupload copies every frame CPU→GPU\n4. Inefficient for high speedup ratios (240x)\n\n## Proposed Solution\n\n### Option 1: Full Hardware Pipeline (VAAPI)\n```python\n# src/frigate_tools/timelapse.py:446-455\nelif hwaccel == HWAccel.VAAPI:\n    input_fps = output_fps / speed\n    cmd.extend([\n        \"-hwaccel\", \"vaapi\",\n        \"-hwaccel_output_format\", \"vaapi\",\n        \"-hwaccel_device\", \"/dev/dri/renderD128\",\n        \"-i\", str(input_path),\n        \"-vf\", f\"fps={output_fps}/{speed},scale_vaapi=format=nv12\",\n        \"-c:v\", \"h264_vaapi\",\n        \"-qp\", \"23\",\n    ])\n```\n\n### Option 2: Frame Selection (More Efficient)\nFor extreme speedups, use select filter to process only needed frames.\n\n### Option 3: Direct Frame Extraction\nSkip concat step for 100x+ speedups, extract frames directly from source files.\n\n## Expected Performance\n- **Target**: \u003c30 seconds for 1 hour of footage (10x improvement)\n- **CPU usage**: \u003c100% (90% reduction)\n- **Full GPU pipeline**: Decode → Filter → Encode all on GPU\n\n## Testing Requirements\n\n### 1. Performance Benchmarks\n- [ ] Measure encode time for 1 hour timelapse (before/after)\n- [ ] Measure CPU usage during encode (before/after)\n- [ ] Measure GPU encoder utilization (should be \u003e0%)\n- [ ] Test multiple speedup ratios: 10x, 60x, 240x, 1000x\n\n### 2. Quality Validation\n- [ ] Compare output quality (visual inspection)\n- [ ] Verify output duration matches target duration\n- [ ] Verify output framerate matches requested fps\n- [ ] Check for frame drops or artifacts\n\n### 3. Hardware Compatibility\n- [ ] Test with VAAPI (Intel QSV)\n- [ ] Test fallback to software encoding if hw fails\n- [ ] Verify detection logic still works\n\n### 4. Edge Cases\n- [ ] Test with various source framerates (5fps, 10fps, 30fps)\n- [ ] Test with different resolutions\n- [ ] Test with corrupted/missing frames in source\n- [ ] Test very short timelapses (10 seconds source)\n- [ ] Test very long timelapses (24+ hours source)\n\n### 5. Regression Testing\n- [ ] Existing timelapse tests still pass\n- [ ] Multi-camera grid timelapses work\n- [ ] Calendar filtering still works\n- [ ] Progress reporting accurate\n\n## Implementation Notes\n\nFile: `src/frigate_tools/timelapse.py`\n- Lines 446-455: Update VAAPI encoding command\n- Lines 433-445: Consider similar updates for QSV\n- Consider adding benchmark/profiling output for testing\n\n## Success Criteria\n- 10x faster encoding for typical use cases\n- \u003c100% CPU usage during encode\n- GPU encoder utilization \u003e0%\n- All tests pass\n- No quality degradation","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-07T09:52:30.846646531-05:00","updated_at":"2025-12-07T09:58:35.525582149-05:00","closed_at":"2025-12-07T09:58:35.525582149-05:00"}
{"id":"frigate-tools-9eh","title":"File list generation with calendar filtering","description":"Input: cameras[], start, end, instance, skip_days[], skip_hours[]. Parse Frigate directory structure (YYYY-MM-DD/HH/camera/MM.SS.mp4). Filter out specified days (e.g., sat,sun) and hours (e.g., 16-8 meaning skip 4pm to 8am). Output: sorted list of files per camera.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:57:50.057834623-05:00","updated_at":"2025-12-06T14:14:31.853575671-05:00","closed_at":"2025-12-06T14:14:31.853575671-05:00","dependencies":[{"issue_id":"frigate-tools-9eh","depends_on_id":"frigate-tools-hgp","type":"blocks","created_at":"2025-12-06T14:05:31.044063671-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-9j8","title":"Add integration test for generate_file_lists with combined filters","description":"test_file_list.py has good unit test coverage but no integration test that exercises generate_file_lists() with BOTH skip_days AND skip_hours applied simultaneously. Add a test case that verifies the combination works correctly (e.g., skip weekends AND skip overnight hours).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-06T14:17:56.105871662-05:00","updated_at":"2025-12-06T14:24:47.421764908-05:00","closed_at":"2025-12-06T14:24:47.421764908-05:00","dependencies":[{"issue_id":"frigate-tools-9j8","depends_on_id":"frigate-tools-9eh","type":"blocks","created_at":"2025-12-06T14:18:14.438725662-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-d4r","title":"Single camera timelapse encoding","description":"Two-step approach: concat copy to temp file, then encode with setpts filter. Calculate speed multiplier from source duration / target duration. Defaults: fast preset, native resolution. Include ffmpeg progress parsing for output.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:57:54.443612512-05:00","updated_at":"2025-12-06T14:18:26.959240024-05:00","closed_at":"2025-12-06T14:18:26.959240024-05:00","dependencies":[{"issue_id":"frigate-tools-d4r","depends_on_id":"frigate-tools-9eh","type":"blocks","created_at":"2025-12-06T14:05:31.054569863-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-dvq","title":"Commit existing frigate-tools work to git","description":"Git log shows commits from a different project (rover). All frigate-tools code (scaffolding, observability, file_list, tests) has not been committed. This is critical - work could be lost. Need to: git add the src/, tests/, pyproject.toml, etc. and commit.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-06T14:17:54.345726503-05:00","updated_at":"2025-12-06T14:20:39.966840117-05:00","closed_at":"2025-12-06T14:20:39.966840117-05:00"}
{"id":"frigate-tools-edl","title":"Implement keyframe-only timelapse extraction (no concat)","description":"## Problem\n\nCurrent timelapse encoding is fundamentally inefficient:\n- Uses `select` filter which **decodes ALL frames** before discarding\n- 1 hour → 15 seconds: Decodes 108,000 frames to keep 450\n- 1 month → 15 seconds: Would decode 77 million frames to keep 450\n- Creates massive intermediate concat files (86GB+ for long timelapses)\n\n## Key Insight\n\n**Keyframe-only extraction is sufficient for ALL timelapse scenarios.**\n\nFrigate recordings have ~1 keyframe per second. For keyframe-only at 30fps output, speedup must be ≥30x. Real timelapse use cases always exceed this:\n\n| Source | Output | Speedup | Works? |\n|--------|--------|---------|--------|\n| 1 hour | 2 min | 30x | ✅ |\n| 1 hour | 15 sec | 240x | ✅ |\n| 1 day | 5 min | 288x | ✅ |\n| 1 month | 15 sec | 172,800x | ✅ |\n\n## Solution: Direct Keyframe Extraction\n\n**Single unified approach - no tiers, no concat:**\n\n```python\ndef create_timelapse(files, target_duration, output_fps=30):\n    frames_needed = int(target_duration * output_fps)\n    total_duration = len(files) * 5.0  # Frigate 5-sec segments\n    interval = total_duration / frames_needed\n    \n    # Calculate which timestamps/files we need\n    timestamps = [i * interval for i in range(frames_needed)]\n    frame_sources = [(files[int(ts/5)], ts % 5) for ts in timestamps]\n    \n    # Extract keyframes directly using -skip_frame nokey\n    # Only decodes keyframes, not all frames!\n    extract_and_encode(frame_sources, output_path, hwaccel)\n```\n\n## Why This Is Fast\n\n**Before:** `concat(720 files) → decode(108k frames) → select(450) → encode`\n**After:** `calculate(450 positions) → extract(450 keyframes) → encode`\n\n- Only decodes 450 keyframes (not 108,000 frames)\n- No intermediate concat file (0GB vs 86GB)\n- Direct seeks to needed timestamps\n\n## Expected Performance\n\n| Scenario | Current | New | Improvement |\n|----------|---------|-----|-------------|\n| 1 hour → 15 sec | 3 min | ~5 sec | **36x faster** |\n| 1 day → 5 min | ~1 hour | ~30 sec | **120x faster** |\n| 1 month → 15 sec | 36+ hours | ~1 min | **2000x faster** |\n\n## Implementation\n\n1. Add `extract_keyframes_for_timelapse()` function\n2. Calculate frame positions → map to source files\n3. Extract keyframes with `-skip_frame nokey -ss {offset}`\n4. Pipe to hardware encoder (VAAPI/QSV)\n5. Replace current concat+encode approach\n\n## Files to Modify\n\n- `src/frigate_tools/timelapse.py` - New implementation\n- `tests/test_timelapse.py` - Update tests\n\n## Success Criteria\n\n- Month-long timelapses in ~1 minute (not 36 hours)\n- No intermediate concat files\n- Works with hardware acceleration","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-07T10:35:14.77413115-05:00","updated_at":"2025-12-07T10:52:04.646083192-05:00","closed_at":"2025-12-07T10:52:04.646083192-05:00"}
{"id":"frigate-tools-ell","title":"Add end-to-end test with real Frigate recordings","description":"","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-06T15:27:03.16217405-05:00","updated_at":"2025-12-06T15:30:12.719331287-05:00","closed_at":"2025-12-06T15:30:12.719331287-05:00"}
{"id":"frigate-tools-exa","title":"Add CLI unit tests for parse_duration and find_frigate_instance","description":"test_cli.py only has 4 tests checking help output. Missing tests for: parse_duration() with various formats (5m, 1h30m, invalid), find_frigate_instance() with mocked paths, and timelapse_create command invocation with mocked dependencies.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-06T14:20:28.76081911-05:00","updated_at":"2025-12-06T14:23:29.250754264-05:00","closed_at":"2025-12-06T14:23:29.250754264-05:00"}
{"id":"frigate-tools-hgp","title":"OTel instrumentation infrastructure","description":"Core observability layer. opentelemetry-sdk, opentelemetry-exporter-otlp, structlog with trace context injection. Decorator/context manager pattern so features get o11y for free. Config via env vars (OTEL_EXPORTER_OTLP_ENDPOINT, OTEL_SERVICE_NAME, etc). Defaults to localhost:4317. Traces for operations, metrics for performance, structured logs. Must be baked into scaffolding.","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-06T14:02:07.914978916-05:00","updated_at":"2025-12-06T14:12:25.694490721-05:00","closed_at":"2025-12-06T14:12:25.694490721-05:00","dependencies":[{"issue_id":"frigate-tools-hgp","depends_on_id":"frigate-tools-pjp","type":"blocks","created_at":"2025-12-06T14:05:31.028863892-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-htm","title":"skip-hours uses wrong timezone","description":"**Problem**\nThe --skip-hours option interprets hours in the wrong timezone (UTC) instead of local time matching the camera's perspective.\n\n**Example**\nUser specifies --skip-hours 16-8 expecting to skip 4pm-8am local time, but it skips 4pm-8am UTC instead, resulting in wrong hours being included/excluded.\n\n**Expected**\nskip-hours should use local timezone consistent with the camera's local time (same as start/end times should work after frigate-tools-0a1 is fixed).\n\n**Related**\nfrigate-tools-0a1 (timezone fix for start/end times) - both issues stem from Frigate storing paths in UTC while CLI accepts local time.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-07T15:57:34.500700716-05:00","updated_at":"2025-12-07T16:03:58.863048561-05:00","closed_at":"2025-12-07T16:03:58.863048561-05:00","dependencies":[{"issue_id":"frigate-tools-htm","depends_on_id":"frigate-tools-0a1","type":"blocks","created_at":"2025-12-07T15:57:39.513828136-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-i6v","title":"Fix tracing depth - CLI missing parent spans","description":"**Problem**\nAll traced spans appear flat/top-level instead of nested hierarchy.\n\n**Root Cause**\nCLI (cli.py) has no traced_operation calls. Each module function (generate_file_lists, create_timelapse, concat_files, etc.) creates its own root span since there's no CLI-level parent span active when they're called.\n\n**Evidence**\n- grep 'traced_operation' on cli.py returns no matches\n- Module functions correctly use traced_operation\n- Child spans within a function ARE nested (e.g., concat_files is child of create_timelapse)\n- But top-level operations from CLI are all siblings\n\n**Fix**\nAdd traced_operation calls in CLI that wrap each command's workflow:\n- timelapse command: wrap with traced_operation('timelapse_create')\n- clip command: wrap with traced_operation('clip_create')\n- etc.\n\nThis creates the parent span that all module-level operations will attach to.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-07T11:26:41.811712801-05:00","updated_at":"2025-12-07T11:30:39.917990382-05:00","closed_at":"2025-12-07T11:30:39.917990382-05:00"}
{"id":"frigate-tools-ijo","title":"Performance testing for timelapse generation approaches","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:33:20.764011153-05:00","updated_at":"2025-12-06T13:48:05.095168329-05:00","closed_at":"2025-12-06T13:48:05.095168329-05:00"}
{"id":"frigate-tools-llw","title":"Multi-camera timelapse ignores target_duration","description":"cli.py:297-301 calls create_grid_video() for multi-camera output but doesn't pass target_duration. The grid video is created at full speed instead of being time-lapsed. Need to either: (1) add timelapse encoding to create_grid_video, or (2) create grid first then apply timelapse encoding as a second step.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-06T14:20:27.963204842-05:00","updated_at":"2025-12-06T14:23:19.929064998-05:00","closed_at":"2025-12-06T14:23:19.929064998-05:00","dependencies":[{"issue_id":"frigate-tools-llw","depends_on_id":"frigate-tools-3s3","type":"blocks","created_at":"2025-12-06T14:20:33.431522919-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-pjp","title":"Project scaffolding - Python project with uv, typer CLI framework, basic structure with timelapse subcommand","description":"Python project setup with uv, typer CLI framework, pytest. Basic CLI structure with timelapse subcommand. Include test infrastructure from the start - all code must have corresponding tests.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:57:45.008430669-05:00","updated_at":"2025-12-06T14:10:01.077159982-05:00","closed_at":"2025-12-06T14:10:01.077159982-05:00"}
{"id":"frigate-tools-q33","title":"Move tempfile import to module level in grid.py","description":"grid.py:207 has 'import tempfile' inside create_grid_video(). Should be at module level for consistency with other imports. Functionally fine but inconsistent style.","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-12-06T14:19:51.034682537-05:00","updated_at":"2025-12-06T14:24:46.373792793-05:00","closed_at":"2025-12-06T14:24:46.373792793-05:00"}
{"id":"frigate-tools-sjz","title":"Add dry-run mode with size estimates and disk space check","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-06T15:01:30.399135934-05:00","updated_at":"2025-12-06T15:04:19.812980944-05:00","closed_at":"2025-12-06T15:04:19.812980944-05:00"}
{"id":"frigate-tools-sum","title":"Implement Two-Pass BSF timelapse for high-speedup scenarios","description":"## Summary\n\nReplace the current high-speedup timelapse implementation with a two-pass bitstream filter (BSF) approach that operates at the packet level without decoding. This should provide 5-10x performance improvement for week-long timelapses.\n\n## Problem\n\nThe current implementation uses `-skip_frame nokey` with the concat demuxer, but **this combination does not work as expected**. According to FFmpeg documentation and community reports, `-discard nokey` is ignored when using `-f concat`, meaning we are still decoding all frames even though we only need keyframes.\n\nCurrent performance for 5-day timelapse (15,480 files):\n- **Time**: 1 hour 49 minutes\n- **Bottleneck**: Decoding 154,000+ frames when we only need ~9,000\n\n## Solution: Two-Pass Bitstream Filter Approach\n\n### Why BSF?\n\nBitstream filters operate on **packets, not decoded frames**. This means:\n1. No decoding overhead (100x faster than filter-based approaches)\n2. No encoding overhead (stream copy)\n3. No quality loss (original keyframes preserved)\n\nThe `noise` BSF with `drop` parameter can select every Nth packet, and `setts` BSF retimes the remaining packets.\n\n### Technical Approach\n\n**Pass 1: Fast Concatenation**\n```bash\nffmpeg -f concat -safe 0 -i list.txt -c copy -an concatenated.mp4\n```\n- Stream copy (no decode/encode)\n- I/O bound, ~3-4 minutes per hour of source footage\n- Creates intermediate file (concern for very large inputs)\n\n**Pass 2: BSF Timelapse**\n```bash\nffmpeg -discard nokey -i concatenated.mp4 -c copy -an \\\n  -bsf:v \"noise=drop='mod(n,{interval})',setts=ts='N/{fps}/TB_OUT'\" \\\n  output.mp4\n```\n- `-discard nokey`: Only read keyframe packets (works on single file!)\n- `noise=drop`: Keep every Nth packet (e.g., every 17th for 500x speedup)\n- `setts`: Retime packets to target framerate\n- Processes 3.5GB in ~2 seconds\n\n### Key Insight\n\nThe `-discard nokey` option **works correctly on a single file** but is ignored with concat demuxer. By concatenating first (Pass 1), we create a single file that BSF can process efficiently (Pass 2).\n\n## Implementation Details\n\n### 1. Keyframe Estimation (Skip Counting)\n\nThe prototype wasted 112s counting keyframes with ffprobe. Instead, estimate:\n\n```python\ndef estimate_keyframes(file_count: int, avg_duration: float = 10.0) -\u003e int:\n    \"\"\"Estimate keyframe count from file count.\n    \n    Frigate recordings have ~1 keyframe per second (GOP=30 at 30fps).\n    Each 10-second segment has ~10 keyframes.\n    \"\"\"\n    return int(file_count * avg_duration)  # ~1 keyframe/second\n```\n\nThis is accurate enough for timelapse purposes (we are not seeking frame-accurate cuts).\n\n### 2. Calculate BSF Parameters\n\n```python\ndef calculate_bsf_params(\n    file_count: int,\n    target_duration: float,\n    output_fps: float = 30.0,\n    avg_file_duration: float = 10.0,\n) -\u003e tuple[int, str, str]:\n    \"\"\"Calculate BSF parameters for timelapse.\n    \n    Returns:\n        (packet_interval, drop_expr, setts_expr)\n    \"\"\"\n    source_duration = file_count * avg_file_duration\n    estimated_keyframes = int(source_duration)  # ~1/second\n    frames_needed = int(target_duration * output_fps)\n    \n    packet_interval = max(1, estimated_keyframes // frames_needed)\n    \n    # BSF expressions\n    drop_expr = f\"mod(n\\\\,{packet_interval})\"  # Keep when mod == 0\n    setts_expr = f\"N/{output_fps}/TB_OUT\"       # Retime to output fps\n    \n    return packet_interval, drop_expr, setts_expr\n```\n\n### 3. Named Pipe Option (Large Inputs)\n\nFor week+ timelapses, the intermediate file can be 50-100GB. Use a named pipe to avoid disk overhead:\n\n```python\ndef create_timelapse_bsf_piped(\n    input_files: list[Path],\n    output_path: Path,\n    ...\n) -\u003e bool:\n    \"\"\"Two-pass BSF with named pipe (no intermediate file).\"\"\"\n    import os\n    \n    fifo_path = output_path.parent / f\".{output_path.stem}_fifo.mp4\"\n    os.mkfifo(fifo_path)\n    \n    try:\n        # Start Pass 2 first (it will block waiting for input)\n        pass2_cmd = [...]  # BSF command reading from fifo\n        pass2_proc = subprocess.Popen(pass2_cmd, ...)\n        \n        # Start Pass 1 (writes to fifo)\n        pass1_cmd = [...]  # Concat command writing to fifo\n        pass1_proc = subprocess.Popen(pass1_cmd, ...)\n        \n        # Wait for both\n        pass1_proc.wait()\n        pass2_proc.wait()\n        \n        return pass2_proc.returncode == 0\n    finally:\n        fifo_path.unlink(missing_ok=True)\n```\n\n**Fallback**: If named pipe fails (filesystem limitations), fall back to temp file.\n\n### 4. Integration with Existing Code\n\nModify `_create_timelapse_keyframe()` in `timelapse.py`:\n\n```python\ndef _create_timelapse_keyframe(\n    input_files: list[Path],\n    output_path: Path,\n    target_duration: float,\n    source_duration: float,\n    output_fps: float = 30.0,\n    ...\n) -\u003e bool:\n    \"\"\"Create timelapse using two-pass BSF approach.\"\"\"\n    \n    # Decide: named pipe vs temp file\n    estimated_size = len(input_files) * 230_000  # ~230KB per 10s segment\n    use_pipe = estimated_size \u003e 10 * 1024**3  # \u003e10GB\n    \n    if use_pipe:\n        return _create_timelapse_bsf_piped(...)\n    else:\n        return _create_timelapse_bsf_file(...)\n```\n\n### 5. Progress Reporting\n\nBSF operations are fast but we still want progress:\n\n**Pass 1 (Concat)**: Report based on files processed (batch progress)\n**Pass 2 (BSF)**: Very fast, just report start/end\n\n```python\n# Pass 1 progress (estimated from batch processing)\ndef concat_progress_callback(progress: ConcatProgress):\n    # Scale to 0-95% (leave 5% for Pass 2)\n    scaled_percent = (progress.percent or 0) * 0.95\n    report_progress(scaled_percent, \"Concatenating files...\")\n\n# Pass 2 progress  \nreport_progress(95, \"Applying timelapse filter...\")\n# ... run BSF ...\nreport_progress(100, \"Complete\")\n```\n\n## Testing Plan\n\n### 1. Unit Tests\n\n```python\ndef test_estimate_keyframes():\n    # 360 files * 10s = 3600 keyframes expected\n    assert estimate_keyframes(360) == 3600\n    \ndef test_calculate_bsf_params():\n    # 360 files, 15s output @ 30fps = 450 frames needed\n    # 3600 keyframes / 450 frames = interval of 8\n    interval, drop, setts = calculate_bsf_params(360, 15.0, 30.0)\n    assert interval == 8\n    assert \"mod(n\\\\,8)\" in drop\n```\n\n### 2. Integration Tests\n\n```python\ndef test_bsf_timelapse_small():\n    \"\"\"Test BSF approach with 10 files.\"\"\"\n    # Create 10 test files\n    # Run BSF timelapse targeting 5s output\n    # Verify output duration ~5s\n    # Verify output plays correctly\n\ndef test_bsf_timelapse_fallback():\n    \"\"\"Test fallback when BSF fails.\"\"\"\n    # Mock BSF failure\n    # Verify fallback to software encoding works\n```\n\n### 3. Performance Benchmarks\n\nRun against actual Frigate data:\n\n| Test Case | Files | Current Time | Expected BSF Time |\n|-----------|-------|--------------|-------------------|\n| 1 hour | 360 | ~6 min | ~3-4 min |\n| 8 hours | 2,880 | ~30 min | ~8-10 min |\n| 5 days (8am-4pm) | 15,480 | 109 min | ~15-20 min |\n| 1 week (8am-4pm) | 21,600 | ~150 min | ~20-25 min |\n\n### 4. Quality Verification\n\n- Compare frame quality between current and BSF output\n- Verify no artifacts or glitches\n- Check frame timing is smooth (no stuttering)\n\n## Edge Cases\n\n1. **Very short source**: If source \u003c target duration, skip timelapse entirely\n2. **Low speedup (\u003c30x)**: Fall back to current concat+encode approach (need inter-frames)\n3. **Single file input**: Skip concat pass, go directly to BSF\n4. **Corrupt files**: Concat will fail on corrupt segments; need error handling\n5. **Disk full**: Named pipe helps, but still need temp file for concat list\n\n## Performance Estimates\n\n### 5-Day Test Case (15,480 files)\n\n| Phase | Current | BSF Approach |\n|-------|---------|--------------|\n| File analysis | ~30s | ~5s (estimation) |\n| Concat | N/A | ~15 min (I/O bound) |\n| Decode | ~90 min | **0** (skipped!) |\n| BSF/Filter | N/A | ~20s |\n| Encode | ~20 min | **0** (stream copy) |\n| **Total** | **109 min** | **~16 min** |\n\n**Speedup: ~7x**\n\n### With Named Pipe (No Intermediate File)\n\nIf we can eliminate the intermediate file with named pipes:\n- Skip disk write/read of ~60GB\n- Estimated additional savings: 5-10 minutes\n- **Potential total: ~10 min (10x speedup)**\n\n## Dependencies\n\n- FFmpeg 4.4+ (for noise BSF with drop parameter)\n- Linux (for named pipes; Windows would need different approach)\n\n## Risks\n\n1. **BSF compatibility**: Older FFmpeg versions may not have noise BSF\n   - Mitigation: Version check, fall back to current approach\n\n2. **Named pipe reliability**: May fail on some filesystems\n   - Mitigation: Automatic fallback to temp file\n\n3. **Keyframe estimation accuracy**: If Frigate changes GOP structure\n   - Mitigation: Sample first file to verify keyframe rate\n\n## References\n\n- [FFmpeg Timelapse from Keyframes](https://video.stackexchange.com/questions/38156/ffmpeg-timelapse-from-some-keyframes)\n- [FFmpeg BSF noise filter](https://ffmpeg.org/ffmpeg-bitstream-filters.html#noise)\n- [FFmpeg BSF setts filter](https://ffmpeg.org/ffmpeg-bitstream-filters.html#setts)\n- Prototype: `prototypes/two_pass_bsf.py`\n\n## Acceptance Criteria\n\n- [ ] 5-day timelapse completes in under 20 minutes\n- [ ] Output quality matches current implementation\n- [ ] Progress reporting works for both passes\n- [ ] Automatic fallback if BSF approach fails\n- [ ] Unit tests for parameter calculation\n- [ ] Integration test with real Frigate files\n- [ ] Documentation updated with new approach","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-07T16:59:44.144926334-05:00","updated_at":"2025-12-07T17:12:59.929002384-05:00","closed_at":"2025-12-07T17:12:59.929002384-05:00"}
{"id":"frigate-tools-sum.1","title":"Validate Two-Pass BSF at scale (5-day test)","description":"## Goal\n\nRun the existing Two-Pass BSF prototype against the full 5-day test case to validate performance claims before investing in full implementation.\n\n## Test Case\n\n```bash\n# Generate file list for 5-day test\nuv run frigate-tools timelapse create \\\n  -c bporchcam \\\n  -s 2025-12-01T08:00 \\\n  -e 2025-12-06T15:00 \\\n  --skip-hours 16-8 \\\n  --dry-run \u003e /tmp/five_day_files.txt\n\n# Run prototype\npython prototypes/two_pass_bsf.py \\\n  --file-list /tmp/five_day_files.txt \\\n  --output /tmp/five_day_bsf.mp4 \\\n  --duration 300 \\\n  --keep-temp\n```\n\n## Measurements Required\n\n1. **Pass 1 time** (concat): Expected ~15-20 min\n2. **Pass 2 time** (BSF): Expected \u003c1 min\n3. **Total time**: Expected \u003c20 min\n4. **Intermediate file size**: Record for planning named pipe threshold\n5. **Output quality**: Visual inspection, compare to current output\n\n## Success Criteria\n\n- Total time under 25 minutes (vs 109 min current = 4x improvement minimum)\n- Output video plays correctly\n- Visual quality acceptable\n\n## If It Fails\n\nDocument why and what adjustments are needed:\n- Did concat fail on certain files?\n- Did BSF produce corrupt output?\n- Was timing estimate way off?\n\n## Deliverables\n\n- Timing results added to this ticket\n- Output video saved for quality comparison\n- Go/no-go recommendation for full implementation","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:00:57.043077002-05:00","updated_at":"2025-12-07T17:07:04.408968078-05:00","closed_at":"2025-12-07T17:07:04.408968078-05:00","dependencies":[{"issue_id":"frigate-tools-sum.1","depends_on_id":"frigate-tools-sum","type":"parent-child","created_at":"2025-12-07T17:00:57.04350932-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-sum.2","title":"Implement keyframe estimation (skip ffprobe counting)","description":"## Goal\n\nReplace the slow ffprobe keyframe counting with estimation based on file count.\n\n## Current Problem\n\nThe prototype spends 112 seconds (35% of total time) counting keyframes:\n\n```python\n# SLOW - requires decode\ndef count_keyframes(file_path: Path) -\u003e int:\n    cmd = [\n        \"ffprobe\", \"-skip_frame\", \"nokey\",\n        \"-count_frames\", ...\n    ]\n```\n\n## Solution\n\nFrigate recordings have predictable keyframe structure:\n- ~10 second segments\n- GOP of 30 at 30fps = 1 keyframe per second\n- Therefore: ~10 keyframes per segment\n\n```python\ndef estimate_keyframes(file_count: int, avg_duration: float = 10.0) -\u003e int:\n    \"\"\"Estimate keyframe count without probing.\n    \n    Frigate segments are ~10s with 1 keyframe/second.\n    Accuracy is sufficient for timelapse interval calculation.\n    \"\"\"\n    return int(file_count * avg_duration)\n```\n\n## Validation\n\nSample first few files to verify estimation is reasonable:\n\n```python\ndef validate_keyframe_estimate(sample_files: list[Path], estimate: int) -\u003e bool:\n    \"\"\"Quick sanity check on keyframe estimate.\"\"\"\n    # Count keyframes in 3 sample files\n    sample_count = sum(count_keyframes_fast(f) for f in sample_files[:3])\n    expected_sample = len(sample_files[:3]) * 10\n    \n    # Allow 50% variance\n    ratio = sample_count / expected_sample\n    return 0.5 \u003c ratio \u003c 1.5\n```\n\n## Files to Modify\n\n- `src/frigate_tools/timelapse.py`: Add `estimate_keyframes()` function\n- Remove or deprecate `count_keyframes()` usage in timelapse path\n\n## Tests\n\n```python\ndef test_estimate_keyframes_accuracy():\n    \"\"\"Compare estimate to actual count on real files.\"\"\"\n    files = get_test_files(10)\n    estimate = estimate_keyframes(10)\n    actual = sum(count_keyframes(f) for f in files)\n    \n    # Should be within 20%\n    assert 0.8 \u003c estimate / actual \u003c 1.2\n```\n\n## Acceptance Criteria\n\n- [ ] Keyframe estimation function implemented\n- [ ] Validation function to catch outliers\n- [ ] Unit tests pass\n- [ ] No ffprobe calls in hot path for timelapse","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:01:12.020625155-05:00","updated_at":"2025-12-07T17:09:04.170891145-05:00","closed_at":"2025-12-07T17:09:04.170891145-05:00","dependencies":[{"issue_id":"frigate-tools-sum.2","depends_on_id":"frigate-tools-sum","type":"parent-child","created_at":"2025-12-07T17:01:12.021286438-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.2","depends_on_id":"frigate-tools-sum.1","type":"blocks","created_at":"2025-12-07T17:03:45.222003822-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-sum.3","title":"Implement core Two-Pass BSF timelapse function","description":"## Goal\n\nImplement the core two-pass BSF timelapse function that will replace `_create_timelapse_keyframe()`.\n\n## Function Signature\n\n```python\ndef _create_timelapse_bsf(\n    input_files: list[Path],\n    output_path: Path,\n    target_duration: float,\n    source_duration: float,\n    output_fps: float = 30.0,\n    progress_callback: Callable[[ProgressInfo], None] | None = None,\n    keep_temp: bool = False,\n) -\u003e bool:\n    \"\"\"Create timelapse using two-pass bitstream filter approach.\n    \n    Pass 1: Concatenate all files with stream copy (no decode)\n    Pass 2: Apply BSF to select keyframes and retime (no decode)\n    \n    This is dramatically faster than decode+encode for high speedups\n    because BSF operates at packet level.\n    \"\"\"\n```\n\n## Implementation\n\n### Pass 1: Concatenation\n\n```python\ndef _bsf_pass1_concat(\n    input_files: list[Path],\n    output_path: Path,\n    progress_callback: Callable[[ConcatProgress], None] | None = None,\n) -\u003e bool:\n    \"\"\"Pass 1: Fast concatenation with stream copy.\"\"\"\n    # Create concat list file\n    concat_list = output_path.parent / f\".{output_path.stem}_list.txt\"\n    with open(concat_list, \"w\") as f:\n        for file_path in input_files:\n            escaped = str(file_path.resolve()).replace(\"'\", \"'\\\\''\")\n            f.write(f\"file '{escaped}'\\n\")\n    \n    cmd = [\n        \"ffmpeg\", \"-y\",\n        \"-f\", \"concat\", \"-safe\", \"0\",\n        \"-i\", str(concat_list),\n        \"-c\", \"copy\",\n        \"-an\",\n        str(output_path),\n    ]\n    \n    # Run with progress monitoring\n    ...\n```\n\n### Pass 2: BSF Timelapse\n\n```python\ndef _bsf_pass2_timelapse(\n    input_path: Path,\n    output_path: Path,\n    packet_interval: int,\n    output_fps: float,\n    progress_callback: Callable[[ProgressInfo], None] | None = None,\n) -\u003e bool:\n    \"\"\"Pass 2: Apply BSF to create timelapse.\"\"\"\n    # Build BSF expression\n    # noise=drop keeps packets where expression is 0 (false)\n    # We keep every Nth packet starting at 0\n    drop_expr = f\"mod(n\\\\,{packet_interval})\"\n    setts_expr = f\"N/{output_fps}/TB_OUT\"\n    \n    cmd = [\n        \"ffmpeg\", \"-y\",\n        \"-discard\", \"nokey\",  # Only read keyframe packets\n        \"-i\", str(input_path),\n        \"-c\", \"copy\",\n        \"-an\",\n        \"-bsf:v\", f\"noise=drop='{drop_expr}',setts=ts='{setts_expr}'\",\n        str(output_path),\n    ]\n    \n    # Run (very fast, ~seconds)\n    ...\n```\n\n### Main Function\n\n```python\ndef _create_timelapse_bsf(\n    input_files: list[Path],\n    output_path: Path,\n    target_duration: float,\n    source_duration: float,\n    output_fps: float = 30.0,\n    progress_callback: Callable[[ProgressInfo], None] | None = None,\n    keep_temp: bool = False,\n) -\u003e bool:\n    logger = get_logger()\n    \n    # Calculate BSF parameters\n    estimated_keyframes = estimate_keyframes(len(input_files))\n    frames_needed = int(target_duration * output_fps)\n    packet_interval = max(1, estimated_keyframes // frames_needed)\n    \n    logger.info(\n        \"Creating timelapse with BSF approach\",\n        file_count=len(input_files),\n        estimated_keyframes=estimated_keyframes,\n        frames_needed=frames_needed,\n        packet_interval=packet_interval,\n    )\n    \n    # Temp file for concatenated video\n    concat_output = output_path.parent / f\".{output_path.stem}_concat.mp4\"\n    \n    try:\n        # Pass 1: Concatenate\n        if progress_callback:\n            # Report 0-90% during concat\n            def concat_progress(p: ConcatProgress):\n                progress_callback(ProgressInfo(\n                    frame=0, fps=0, time_seconds=0, speed=0,\n                    percent=(p.percent or 0) * 0.9\n                ))\n        \n        if not _bsf_pass1_concat(input_files, concat_output, concat_progress):\n            logger.error(\"BSF Pass 1 (concat) failed\")\n            return False\n        \n        # Pass 2: BSF timelapse\n        if progress_callback:\n            progress_callback(ProgressInfo(\n                frame=0, fps=0, time_seconds=0, speed=0,\n                percent=95.0\n            ))\n        \n        if not _bsf_pass2_timelapse(\n            concat_output, output_path, packet_interval, output_fps\n        ):\n            logger.error(\"BSF Pass 2 (timelapse) failed\")\n            return False\n        \n        if progress_callback:\n            progress_callback(ProgressInfo(\n                frame=frames_needed, fps=0,\n                time_seconds=target_duration, speed=0,\n                percent=100.0\n            ))\n        \n        return True\n        \n    finally:\n        if not keep_temp:\n            concat_output.unlink(missing_ok=True)\n```\n\n## Error Handling\n\n1. **Concat failure**: Log error, return False (caller can fall back)\n2. **BSF failure**: May indicate FFmpeg version issue; log and return False\n3. **Disk full**: Check available space before starting concat\n\n## FFmpeg Version Check\n\nBSF noise filter with `drop` parameter requires FFmpeg 4.4+:\n\n```python\ndef check_ffmpeg_bsf_support() -\u003e bool:\n    \"\"\"Check if FFmpeg supports required BSF features.\"\"\"\n    result = subprocess.run(\n        [\"ffmpeg\", \"-bsfs\"],\n        capture_output=True, text=True\n    )\n    return \"noise\" in result.stdout\n```\n\n## Files to Modify\n\n- `src/frigate_tools/timelapse.py`:\n  - Add `_bsf_pass1_concat()`\n  - Add `_bsf_pass2_timelapse()`\n  - Add `_create_timelapse_bsf()`\n  - Add `check_ffmpeg_bsf_support()`\n\n## Tests\n\n```python\ndef test_bsf_pass1_concat(tmp_path, test_videos):\n    \"\"\"Test concat pass produces valid output.\"\"\"\n    output = tmp_path / \"concat.mp4\"\n    assert _bsf_pass1_concat(test_videos, output)\n    assert output.exists()\n    duration = get_video_duration(output)\n    assert duration \u003e 0\n\ndef test_bsf_pass2_timelapse(tmp_path, concat_video):\n    \"\"\"Test BSF pass produces timelapse.\"\"\"\n    output = tmp_path / \"timelapse.mp4\"\n    assert _bsf_pass2_timelapse(concat_video, output, 10, 30.0)\n    assert output.exists()\n    # Verify duration is reduced\n\ndef test_create_timelapse_bsf_integration(tmp_path, test_videos):\n    \"\"\"End-to-end BSF timelapse test.\"\"\"\n    output = tmp_path / \"timelapse.mp4\"\n    assert _create_timelapse_bsf(\n        test_videos, output,\n        target_duration=5.0,\n        source_duration=100.0,\n    )\n    duration = get_video_duration(output)\n    assert 4.0 \u003c duration \u003c 6.0  # Within tolerance\n```\n\n## Acceptance Criteria\n\n- [ ] `_bsf_pass1_concat()` implemented and tested\n- [ ] `_bsf_pass2_timelapse()` implemented and tested\n- [ ] `_create_timelapse_bsf()` integrates both passes\n- [ ] Progress callback works for both passes\n- [ ] Error handling for common failure modes\n- [ ] FFmpeg version check implemented","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:01:41.961647318-05:00","updated_at":"2025-12-07T17:09:04.17175121-05:00","closed_at":"2025-12-07T17:09:04.17175121-05:00","dependencies":[{"issue_id":"frigate-tools-sum.3","depends_on_id":"frigate-tools-sum","type":"parent-child","created_at":"2025-12-07T17:01:41.962062638-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.3","depends_on_id":"frigate-tools-sum.1","type":"blocks","created_at":"2025-12-07T17:03:45.23997474-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.3","depends_on_id":"frigate-tools-sum.2","type":"blocks","created_at":"2025-12-07T17:03:45.257609601-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-sum.4","title":"Add named pipe support for large timelapses","description":"## Goal\n\nFor very large timelapses (week+), avoid creating massive intermediate files by using named pipes (FIFOs) to stream data between Pass 1 and Pass 2.\n\n## Problem\n\nA week of 8am-4pm footage = ~21,600 files = ~60-80GB intermediate file. This:\n- Requires significant disk space\n- Doubles I/O (write then read)\n- Slows down the overall process\n\n## Solution\n\nUse a named pipe (FIFO) so Pass 1 writes directly to Pass 2:\n\n```\nPass 1 (concat) → [named pipe] → Pass 2 (BSF)\n```\n\nNo intermediate file is written to disk.\n\n## Implementation\n\n```python\nimport os\nimport threading\n\ndef _create_timelapse_bsf_piped(\n    input_files: list[Path],\n    output_path: Path,\n    target_duration: float,\n    source_duration: float,\n    output_fps: float = 30.0,\n    progress_callback: Callable[[ProgressInfo], None] | None = None,\n) -\u003e bool:\n    \"\"\"Two-pass BSF with named pipe (no intermediate file).\"\"\"\n    logger = get_logger()\n    \n    # Calculate BSF parameters\n    estimated_keyframes = estimate_keyframes(len(input_files))\n    frames_needed = int(target_duration * output_fps)\n    packet_interval = max(1, estimated_keyframes // frames_needed)\n    \n    # Create named pipe\n    fifo_path = output_path.parent / f\".{output_path.stem}_fifo.mp4\"\n    if fifo_path.exists():\n        fifo_path.unlink()\n    os.mkfifo(fifo_path)\n    \n    try:\n        # Build commands\n        concat_list = _create_concat_list(input_files, output_path.parent)\n        \n        pass1_cmd = [\n            \"ffmpeg\", \"-y\",\n            \"-f\", \"concat\", \"-safe\", \"0\",\n            \"-i\", str(concat_list),\n            \"-c\", \"copy\", \"-an\",\n            str(fifo_path),  # Write to FIFO\n        ]\n        \n        drop_expr = f\"mod(n\\\\,{packet_interval})\"\n        setts_expr = f\"N/{output_fps}/TB_OUT\"\n        \n        pass2_cmd = [\n            \"ffmpeg\", \"-y\",\n            \"-discard\", \"nokey\",\n            \"-i\", str(fifo_path),  # Read from FIFO\n            \"-c\", \"copy\", \"-an\",\n            \"-bsf:v\", f\"noise=drop='{drop_expr}',setts=ts='{setts_expr}'\",\n            str(output_path),\n        ]\n        \n        # Start Pass 2 FIRST (it will block waiting for FIFO input)\n        pass2_proc = subprocess.Popen(\n            pass2_cmd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        \n        # Start Pass 1 (writes to FIFO, unblocking Pass 2)\n        pass1_proc = subprocess.Popen(\n            pass1_cmd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        \n        # Wait for Pass 1 to complete (this drives the pipeline)\n        _, pass1_stderr = pass1_proc.communicate()\n        \n        # Wait for Pass 2 to complete (should finish shortly after Pass 1)\n        _, pass2_stderr = pass2_proc.communicate()\n        \n        if pass1_proc.returncode \\!= 0:\n            logger.error(\"Piped BSF Pass 1 failed\", stderr=pass1_stderr.decode())\n            return False\n            \n        if pass2_proc.returncode \\!= 0:\n            logger.error(\"Piped BSF Pass 2 failed\", stderr=pass2_stderr.decode())\n            return False\n        \n        return True\n        \n    finally:\n        fifo_path.unlink(missing_ok=True)\n        concat_list.unlink(missing_ok=True)\n```\n\n## When to Use Piped vs File\n\n```python\ndef _create_timelapse_bsf(\n    input_files: list[Path],\n    output_path: Path,\n    ...\n) -\u003e bool:\n    # Estimate intermediate file size\n    # Frigate segments are ~230KB per 10 seconds\n    estimated_bytes = len(input_files) * 230_000\n    \n    # Use pipe for inputs \u003e10GB, file for smaller\n    use_pipe = estimated_bytes \u003e 10 * 1024**3\n    \n    if use_pipe:\n        logger.info(\"Using named pipe for large timelapse\", \n                    estimated_size_gb=estimated_bytes / 1024**3)\n        success = _create_timelapse_bsf_piped(...)\n        if not success:\n            logger.warning(\"Piped approach failed, falling back to file\")\n            success = _create_timelapse_bsf_file(...)\n        return success\n    else:\n        return _create_timelapse_bsf_file(...)\n```\n\n## Platform Considerations\n\nNamed pipes are a POSIX feature. For Windows compatibility:\n\n```python\nimport sys\n\ndef supports_named_pipes() -\u003e bool:\n    \"\"\"Check if platform supports named pipes.\"\"\"\n    return sys.platform \\!= \"win32\"\n```\n\nOn Windows, always use the file-based approach (or consider using subprocess pipes differently).\n\n## Error Handling\n\n1. **FIFO creation fails**: Fall back to file-based approach\n2. **Pass 2 starts but Pass 1 fails**: Pass 2 will hang; need timeout\n3. **Filesystem doesnt support FIFO**: Fall back to file\n\n```python\ndef _create_timelapse_bsf_piped(...) -\u003e bool:\n    try:\n        os.mkfifo(fifo_path)\n    except OSError as e:\n        logger.warning(f\"Cannot create FIFO: {e}, falling back to file\")\n        return False  # Caller will use file-based approach\n```\n\n## Progress Reporting\n\nWith piped approach, progress is harder to track since both processes run concurrently. Options:\n\n1. **Estimate from time elapsed**: Less accurate but simple\n2. **Monitor output file size growth**: Approximate progress\n3. **Just report start/end**: Acceptable for advanced users\n\n```python\n# Simple approach: report based on elapsed time vs estimate\nestimated_time = len(input_files) * 0.5  # ~0.5s per file\nstart_time = time.time()\n\nwhile pass1_proc.poll() is None:\n    elapsed = time.time() - start_time\n    percent = min(95, (elapsed / estimated_time) * 100)\n    if progress_callback:\n        progress_callback(ProgressInfo(..., percent=percent))\n    time.sleep(1)\n```\n\n## Tests\n\n```python\n@pytest.mark.skipif(sys.platform == \"win32\", reason=\"Named pipes not supported\")\ndef test_bsf_piped_small(tmp_path, test_videos):\n    \"\"\"Test piped approach with small input.\"\"\"\n    output = tmp_path / \"timelapse.mp4\"\n    assert _create_timelapse_bsf_piped(\n        test_videos, output,\n        target_duration=5.0,\n        source_duration=100.0,\n    )\n    assert output.exists()\n\ndef test_bsf_fallback_on_pipe_failure(tmp_path, test_videos, monkeypatch):\n    \"\"\"Test fallback when pipe creation fails.\"\"\"\n    def mock_mkfifo(path):\n        raise OSError(\"Filesystem does not support FIFOs\")\n    \n    monkeypatch.setattr(os, \"mkfifo\", mock_mkfifo)\n    \n    # Should fall back to file-based approach\n    output = tmp_path / \"timelapse.mp4\"\n    assert _create_timelapse_bsf(test_videos, output, ...)\n```\n\n## Files to Modify\n\n- `src/frigate_tools/timelapse.py`:\n  - Add `_create_timelapse_bsf_piped()`\n  - Add `supports_named_pipes()`\n  - Modify `_create_timelapse_bsf()` to choose approach\n\n## Acceptance Criteria\n\n- [ ] Named pipe implementation working on Linux\n- [ ] Automatic fallback to file-based on failure\n- [ ] Platform detection skips pipe on Windows\n- [ ] Progress reporting (even if approximate)\n- [ ] Unit tests with skip for Windows\n- [ ] Integration test verifies fallback works","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:02:18.126850835-05:00","updated_at":"2025-12-07T17:12:59.926244588-05:00","closed_at":"2025-12-07T17:12:59.926244588-05:00","dependencies":[{"issue_id":"frigate-tools-sum.4","depends_on_id":"frigate-tools-sum","type":"parent-child","created_at":"2025-12-07T17:02:18.128582735-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.4","depends_on_id":"frigate-tools-sum.3","type":"blocks","created_at":"2025-12-07T17:03:45.267205017-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-sum.5","title":"Integrate BSF approach into timelapse.py","description":"## Goal\n\nReplace the current `_create_timelapse_keyframe()` implementation with the new BSF approach, while maintaining backward compatibility and fallback behavior.\n\n## Current Code Path\n\n```\ncreate_timelapse()\n  ├── speedup \u003e= 30x → _create_timelapse_keyframe()  # REPLACE THIS\n  └── speedup \u003c 30x  → _create_timelapse_concat()    # Keep as-is\n```\n\n## New Code Path\n\n```\ncreate_timelapse()\n  ├── speedup \u003e= 30x → _create_timelapse_bsf()       # NEW\n  │     ├── check_ffmpeg_bsf_support()\n  │     ├── input \u003e 10GB → _create_timelapse_bsf_piped()\n  │     │     └── fallback → _create_timelapse_bsf_file()\n  │     └── input \u003c= 10GB → _create_timelapse_bsf_file()\n  │           └── fallback → _create_timelapse_keyframe()  # OLD (kept as fallback)\n  └── speedup \u003c 30x  → _create_timelapse_concat()    # Unchanged\n```\n\n## Changes to create_timelapse()\n\n```python\ndef create_timelapse(\n    input_files: list[Path],\n    output_path: Path,\n    target_duration: float,\n    output_fps: float = 30.0,\n    preset: str = \"fast\",\n    progress_callback: Callable[[ProgressInfo], None] | None = None,\n    keep_temp: bool = False,\n    hwaccel: HWAccel | None = None,\n    use_bsf: bool = True,  # NEW: Allow disabling BSF approach\n) -\u003e bool:\n    \"\"\"Create a timelapse video from input files.\n    \n    For high speedups (\u003e=30x), uses two-pass BSF approach by default:\n    - Pass 1: Fast concat with stream copy\n    - Pass 2: Bitstream filter for keyframe selection\n    \n    This avoids decode/encode entirely, providing 5-10x speedup.\n    Set use_bsf=False to use the older decode+encode approach.\n    \"\"\"\n    ...\n    \n    if use_keyframe_only:\n        if use_bsf and check_ffmpeg_bsf_support():\n            success = _create_timelapse_bsf(\n                input_files=input_files,\n                output_path=output_path,\n                target_duration=target_duration,\n                source_duration=source_duration,\n                output_fps=output_fps,\n                progress_callback=progress_callback,\n                keep_temp=keep_temp,\n            )\n            if success:\n                return True\n            logger.warning(\"BSF approach failed, falling back to decode+encode\")\n        \n        # Fallback to original approach\n        return _create_timelapse_keyframe(\n            input_files=input_files,\n            output_path=output_path,\n            target_duration=target_duration,\n            source_duration=source_duration,\n            output_fps=output_fps,\n            preset=preset,\n            progress_callback=progress_callback,\n            keep_temp=keep_temp,\n            hwaccel=hwaccel,\n        )\n```\n\n## CLI Changes\n\nAdd `--no-bsf` flag to timelapse command:\n\n```python\n@click.option(\n    \"--no-bsf\",\n    is_flag=True,\n    help=\"Disable BSF optimization (use decode+encode approach)\",\n)\ndef timelapse_create(..., no_bsf: bool):\n    ...\n    create_timelapse(..., use_bsf=not no_bsf)\n```\n\n## Logging\n\nAdd clear logging about which approach is being used:\n\n```python\nlogger.info(\n    \"Creating timelapse\",\n    approach=\"bsf\" if use_bsf else \"decode_encode\",\n    file_count=len(input_files),\n    target_duration=f\"{target_duration:.0f}s\",\n    speedup=f\"{speedup:.0f}x\",\n)\n```\n\n## Keep Old Implementation\n\nDo NOT delete `_create_timelapse_keyframe()`. Keep it as:\n1. Fallback when BSF fails\n2. Option for users who prefer decode+encode\n3. Comparison baseline for testing\n\nRename to make its role clear:\n\n```python\ndef _create_timelapse_keyframe_legacy(\n    ...\n) -\u003e bool:\n    \"\"\"Create timelapse using keyframe decode + encode approach.\n    \n    This is the fallback when BSF approach is unavailable or fails.\n    Slower than BSF but more compatible with different FFmpeg versions.\n    \"\"\"\n```\n\n## Migration Notes\n\n- Default behavior changes (BSF by default)\n- Users should see faster timelapses automatically  \n- If issues arise, `--no-bsf` provides escape hatch\n- Log clearly which approach is being used\n\n## Tests\n\n```python\ndef test_create_timelapse_uses_bsf_by_default(tmp_path, test_videos, mocker):\n    \"\"\"Verify BSF is used for high speedups by default.\"\"\"\n    mock_bsf = mocker.patch(\"frigate_tools.timelapse._create_timelapse_bsf\")\n    mock_bsf.return_value = True\n    \n    create_timelapse(test_videos, tmp_path / \"out.mp4\", target_duration=1.0)\n    \n    mock_bsf.assert_called_once()\n\ndef test_create_timelapse_fallback_on_bsf_failure(tmp_path, test_videos, mocker):\n    \"\"\"Verify fallback to legacy when BSF fails.\"\"\"\n    mock_bsf = mocker.patch(\"frigate_tools.timelapse._create_timelapse_bsf\")\n    mock_bsf.return_value = False\n    \n    mock_legacy = mocker.patch(\"frigate_tools.timelapse._create_timelapse_keyframe_legacy\")\n    mock_legacy.return_value = True\n    \n    result = create_timelapse(test_videos, tmp_path / \"out.mp4\", target_duration=1.0)\n    \n    assert result is True\n    mock_bsf.assert_called_once()\n    mock_legacy.assert_called_once()\n\ndef test_create_timelapse_no_bsf_flag(tmp_path, test_videos, mocker):\n    \"\"\"Verify --no-bsf skips BSF approach.\"\"\"\n    mock_bsf = mocker.patch(\"frigate_tools.timelapse._create_timelapse_bsf\")\n    mock_legacy = mocker.patch(\"frigate_tools.timelapse._create_timelapse_keyframe_legacy\")\n    mock_legacy.return_value = True\n    \n    create_timelapse(test_videos, tmp_path / \"out.mp4\", target_duration=1.0, use_bsf=False)\n    \n    mock_bsf.assert_not_called()\n    mock_legacy.assert_called_once()\n```\n\n## Files to Modify\n\n- `src/frigate_tools/timelapse.py`:\n  - Modify `create_timelapse()` to use BSF by default\n  - Rename `_create_timelapse_keyframe()` to `_create_timelapse_keyframe_legacy()`\n  - Add `use_bsf` parameter\n  \n- `src/frigate_tools/cli/timelapse.py` (or wherever CLI is):\n  - Add `--no-bsf` flag\n\n## Acceptance Criteria\n\n- [ ] BSF approach used by default for speedup \u003e= 30x\n- [ ] Automatic fallback to legacy on BSF failure\n- [ ] `--no-bsf` CLI flag works\n- [ ] Clear logging of which approach is used\n- [ ] Legacy implementation preserved as fallback\n- [ ] All existing tests still pass\n- [ ] New tests for BSF/fallback behavior","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:02:47.975562672-05:00","updated_at":"2025-12-07T17:12:59.927289747-05:00","closed_at":"2025-12-07T17:12:59.927289747-05:00","dependencies":[{"issue_id":"frigate-tools-sum.5","depends_on_id":"frigate-tools-sum","type":"parent-child","created_at":"2025-12-07T17:02:47.975976777-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.5","depends_on_id":"frigate-tools-sum.3","type":"blocks","created_at":"2025-12-07T17:03:45.276627174-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.5","depends_on_id":"frigate-tools-sum.4","type":"blocks","created_at":"2025-12-07T17:03:45.286222371-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-sum.6","title":"Add comprehensive tests for BSF timelapse","description":"## Goal\n\nEnsure the BSF timelapse implementation is thoroughly tested with unit tests, integration tests, and performance benchmarks.\n\n## Test Categories\n\n### 1. Unit Tests\n\n#### Parameter Calculation\n\n```python\nclass TestBSFParameters:\n    def test_estimate_keyframes_standard(self):\n        \"\"\"Standard 10s Frigate segments.\"\"\"\n        assert estimate_keyframes(360) == 3600  # 1 hour\n        assert estimate_keyframes(1) == 10\n        \n    def test_estimate_keyframes_custom_duration(self):\n        \"\"\"Non-standard segment durations.\"\"\"\n        assert estimate_keyframes(100, avg_duration=5.0) == 500\n        \n    def test_calculate_bsf_params_high_speedup(self):\n        \"\"\"High speedup scenario (500x).\"\"\"\n        # 15480 files * 10s = 154800s source\n        # 300s target @ 30fps = 9000 frames\n        # 154800 keyframes / 9000 = interval 17\n        interval, drop, setts = calculate_bsf_params(\n            file_count=15480,\n            target_duration=300.0,\n            output_fps=30.0,\n        )\n        assert interval == 17\n        assert \"mod(n\\\\,17)\" in drop\n        assert \"N/30/TB_OUT\" in setts\n        \n    def test_calculate_bsf_params_low_speedup(self):\n        \"\"\"Low speedup where interval would be \u003c 1.\"\"\"\n        # Edge case: more frames needed than keyframes available\n        interval, _, _ = calculate_bsf_params(\n            file_count=10,\n            target_duration=60.0,  # Want 60s from 100s source\n            output_fps=30.0,\n        )\n        assert interval == 1  # Cannot be less than 1\n```\n\n#### FFmpeg Support Detection\n\n```python\nclass TestFFmpegSupport:\n    def test_check_bsf_support_available(self, mocker):\n        \"\"\"FFmpeg with noise BSF available.\"\"\"\n        mock_run = mocker.patch(\"subprocess.run\")\n        mock_run.return_value.stdout = \"... noise ...\"\n        \n        assert check_ffmpeg_bsf_support() is True\n        \n    def test_check_bsf_support_missing(self, mocker):\n        \"\"\"FFmpeg without noise BSF.\"\"\"\n        mock_run = mocker.patch(\"subprocess.run\")\n        mock_run.return_value.stdout = \"... other_bsf ...\"\n        \n        assert check_ffmpeg_bsf_support() is False\n```\n\n### 2. Integration Tests\n\n#### Pass 1 (Concat)\n\n```python\nclass TestBSFPass1:\n    def test_concat_creates_valid_output(self, tmp_path, test_video_files):\n        \"\"\"Concat produces playable video.\"\"\"\n        output = tmp_path / \"concat.mp4\"\n        assert _bsf_pass1_concat(test_video_files, output)\n        \n        # Verify output\n        assert output.exists()\n        assert output.stat().st_size \u003e 0\n        duration = get_video_duration(output)\n        expected = len(test_video_files) * 10.0  # ~10s per file\n        assert abs(duration - expected) \u003c 1.0  # Within 1 second\n        \n    def test_concat_handles_special_characters(self, tmp_path):\n        \"\"\"Files with spaces and quotes in names.\"\"\"\n        # Create test files with special names\n        special_files = [\n            tmp_path / \"file with spaces.mp4\",\n            tmp_path / \"file'quote.mp4\",\n        ]\n        # ... create files ...\n        \n        output = tmp_path / \"concat.mp4\"\n        assert _bsf_pass1_concat(special_files, output)\n        \n    def test_concat_progress_callback(self, tmp_path, test_video_files):\n        \"\"\"Progress callback is invoked.\"\"\"\n        progress_values = []\n        def callback(p):\n            progress_values.append(p.percent)\n        \n        output = tmp_path / \"concat.mp4\"\n        _bsf_pass1_concat(test_video_files, output, progress_callback=callback)\n        \n        assert len(progress_values) \u003e 0\n        assert progress_values[-1] \u003e= 90  # Should reach near 100%\n```\n\n#### Pass 2 (BSF)\n\n```python\nclass TestBSFPass2:\n    def test_bsf_reduces_duration(self, tmp_path, concat_video):\n        \"\"\"BSF timelapse reduces video duration.\"\"\"\n        output = tmp_path / \"timelapse.mp4\"\n        source_duration = get_video_duration(concat_video)\n        \n        # Target: 10x speedup\n        assert _bsf_pass2_timelapse(\n            concat_video, output,\n            packet_interval=10,\n            output_fps=30.0,\n        )\n        \n        output_duration = get_video_duration(output)\n        assert output_duration \u003c source_duration / 5  # At least 5x reduction\n        \n    def test_bsf_output_plays_correctly(self, tmp_path, concat_video):\n        \"\"\"BSF output can be played by ffplay/ffprobe.\"\"\"\n        output = tmp_path / \"timelapse.mp4\"\n        _bsf_pass2_timelapse(concat_video, output, 10, 30.0)\n        \n        # Verify with ffprobe\n        result = subprocess.run(\n            [\"ffprobe\", \"-v\", \"error\", str(output)],\n            capture_output=True,\n        )\n        assert result.returncode == 0\n```\n\n#### End-to-End\n\n```python\nclass TestBSFEndToEnd:\n    def test_full_bsf_timelapse(self, tmp_path, test_video_files):\n        \"\"\"Complete BSF timelapse workflow.\"\"\"\n        output = tmp_path / \"timelapse.mp4\"\n        \n        # 10 files * 10s = 100s source → 5s target (20x speedup)\n        assert _create_timelapse_bsf(\n            test_video_files,\n            output,\n            target_duration=5.0,\n            source_duration=100.0,\n        )\n        \n        duration = get_video_duration(output)\n        assert 4.0 \u003c duration \u003c 6.0\n        \n    def test_bsf_fallback_to_file_on_pipe_failure(self, tmp_path, test_video_files, mocker):\n        \"\"\"Falls back to file-based when pipe fails.\"\"\"\n        # Mock mkfifo to fail\n        mocker.patch(\"os.mkfifo\", side_effect=OSError(\"No FIFO support\"))\n        \n        output = tmp_path / \"timelapse.mp4\"\n        # Should still succeed via fallback\n        assert _create_timelapse_bsf(\n            test_video_files, output,\n            target_duration=5.0,\n            source_duration=100.0,\n        )\n```\n\n### 3. Performance Benchmarks\n\n```python\n@pytest.mark.benchmark\nclass TestBSFPerformance:\n    def test_bsf_faster_than_legacy(self, benchmark_videos):\n        \"\"\"BSF approach is faster than decode+encode.\"\"\"\n        import time\n        \n        # Time BSF approach\n        start = time.time()\n        _create_timelapse_bsf(benchmark_videos, \"/tmp/bsf.mp4\", 15.0, 3600.0)\n        bsf_time = time.time() - start\n        \n        # Time legacy approach\n        start = time.time()\n        _create_timelapse_keyframe_legacy(benchmark_videos, \"/tmp/legacy.mp4\", 15.0, 3600.0)\n        legacy_time = time.time() - start\n        \n        # BSF should be at least 3x faster\n        assert bsf_time \u003c legacy_time / 3\n        \n    def test_bsf_scales_linearly(self, tmp_path):\n        \"\"\"Time scales roughly linearly with input size.\"\"\"\n        times = []\n        for file_count in [100, 200, 400]:\n            files = create_test_files(file_count, tmp_path)\n            start = time.time()\n            _create_timelapse_bsf(files, tmp_path / f\"out_{file_count}.mp4\", 15.0, file_count * 10.0)\n            times.append(time.time() - start)\n        \n        # Verify roughly linear scaling (2x files ≈ 2x time)\n        ratio_1 = times[1] / times[0]\n        ratio_2 = times[2] / times[1]\n        assert 1.5 \u003c ratio_1 \u003c 2.5\n        assert 1.5 \u003c ratio_2 \u003c 2.5\n```\n\n### 4. Edge Cases\n\n```python\nclass TestBSFEdgeCases:\n    def test_single_file_input(self, tmp_path, single_test_video):\n        \"\"\"Single file should skip concat pass.\"\"\"\n        output = tmp_path / \"timelapse.mp4\"\n        assert _create_timelapse_bsf(\n            [single_test_video], output,\n            target_duration=1.0,\n            source_duration=10.0,\n        )\n        \n    def test_very_short_target(self, tmp_path, test_video_files):\n        \"\"\"Very short target duration (1 second).\"\"\"\n        output = tmp_path / \"timelapse.mp4\"\n        assert _create_timelapse_bsf(\n            test_video_files, output,\n            target_duration=1.0,\n            source_duration=100.0,\n        )\n        duration = get_video_duration(output)\n        assert 0.5 \u003c duration \u003c 2.0\n        \n    def test_source_shorter_than_target(self, tmp_path, test_video_files):\n        \"\"\"Source duration \u003c target duration should handle gracefully.\"\"\"\n        output = tmp_path / \"timelapse.mp4\"\n        # 100s source, 200s target = no speedup needed\n        result = _create_timelapse_bsf(\n            test_video_files, output,\n            target_duration=200.0,\n            source_duration=100.0,\n        )\n        # Should either succeed with no change or return False gracefully\n        \n    def test_corrupt_input_file(self, tmp_path, test_video_files):\n        \"\"\"Corrupt file in input list.\"\"\"\n        # Add a corrupt file\n        corrupt = tmp_path / \"corrupt.mp4\"\n        corrupt.write_bytes(b\"not a video\")\n        \n        output = tmp_path / \"timelapse.mp4\"\n        # Should fail gracefully\n        result = _create_timelapse_bsf(\n            test_video_files + [corrupt], output,\n            target_duration=5.0,\n            source_duration=110.0,\n        )\n        assert result is False  # Or True if it skips corrupt file\n```\n\n## Test Fixtures\n\n```python\n@pytest.fixture\ndef test_video_files(tmp_path):\n    \"\"\"Create 10 test video files (~10s each).\"\"\"\n    files = []\n    for i in range(10):\n        path = tmp_path / f\"video_{i:03d}.mp4\"\n        create_test_video(path, duration=10.0)\n        files.append(path)\n    return files\n\n@pytest.fixture\ndef concat_video(tmp_path, test_video_files):\n    \"\"\"Pre-concatenated video for Pass 2 tests.\"\"\"\n    output = tmp_path / \"concat.mp4\"\n    _bsf_pass1_concat(test_video_files, output)\n    return output\n\n@pytest.fixture\ndef benchmark_videos(tmp_path):\n    \"\"\"360 test files for benchmark tests (1 hour equivalent).\"\"\"\n    files = []\n    for i in range(360):\n        path = tmp_path / f\"video_{i:04d}.mp4\"\n        create_test_video(path, duration=10.0)\n        files.append(path)\n    return files\n\ndef create_test_video(path: Path, duration: float = 10.0):\n    \"\"\"Create a test video file with ffmpeg.\"\"\"\n    subprocess.run([\n        \"ffmpeg\", \"-y\",\n        \"-f\", \"lavfi\",\n        \"-i\", f\"testsrc=duration={duration}:size=320x240:rate=30\",\n        \"-c:v\", \"libx264\",\n        \"-preset\", \"ultrafast\",\n        str(path),\n    ], capture_output=True, check=True)\n```\n\n## Files to Create/Modify\n\n- `tests/test_timelapse_bsf.py`: New test file for BSF-specific tests\n- `tests/conftest.py`: Add fixtures\n- `tests/test_timelapse.py`: Update existing tests if needed\n\n## CI Considerations\n\n- Benchmark tests should be optional (`pytest -m benchmark`)\n- May need to skip some tests in CI due to ffmpeg availability\n- Consider test video caching to speed up CI\n\n## Acceptance Criteria\n\n- [ ] Unit tests for parameter calculation\n- [ ] Unit tests for FFmpeg support detection  \n- [ ] Integration tests for Pass 1 (concat)\n- [ ] Integration tests for Pass 2 (BSF)\n- [ ] End-to-end integration tests\n- [ ] Edge case tests\n- [ ] Performance benchmark tests (optional in CI)\n- [ ] All tests pass locally\n- [ ] Tests pass in CI","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:03:38.935749834-05:00","updated_at":"2025-12-07T17:12:59.928154263-05:00","closed_at":"2025-12-07T17:12:59.928154263-05:00","dependencies":[{"issue_id":"frigate-tools-sum.6","depends_on_id":"frigate-tools-sum","type":"parent-child","created_at":"2025-12-07T17:03:38.936185579-05:00","created_by":"daemon"},{"issue_id":"frigate-tools-sum.6","depends_on_id":"frigate-tools-sum.5","type":"blocks","created_at":"2025-12-07T17:03:45.296959625-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-szd","title":"Fix observability: traces not reaching Datadog due to batch processor","description":"## Problem\n\nfrigate-tools traces are not appearing in Datadog despite:\n- OTLP receiver configured and listening on localhost:4317 ✅\n- Successful gRPC connection from app to collector ✅\n- Traces being created with proper context ✅\n- Other long-running apps successfully sending traces ✅\n\n**Root Cause**: CLI uses `BatchSpanProcessor` which batches spans for efficiency, but short-lived CLI commands exit before the batch is sent to the collector. The `atexit.register(shutdown_observability)` hook doesn't give enough time for async export.\n\n## Evidence\n\n1. **Test with sync export works**: When testing with `init_observability(sync_export=True)`, traces include proper context:\n   ```json\n   {\"trace_id\": \"951613ab1c92e98da2384265ce6d632a\", \"span_id\": \"309f8a4a77a8f6c5\"}\n   ```\n\n2. **No frigate-tools traces in Datadog agent logs**: Only `service.name:agent` traces visible, no `service.name:frigate-tools`\n\n3. **Short-lived process issue**: CLI commands finish in seconds/minutes, process exits before BatchSpanProcessor flushes\n\n## Current Implementation\n\n**src/frigate_tools/observability.py:86-88**\n```python\nprocessor = (\n    SimpleSpanProcessor(exporter) if sync_export else BatchSpanProcessor(exporter)\n)\n```\n\n**src/frigate_tools/cli.py:44-45**\n```python\ninit_observability()  # Uses BatchSpanProcessor by default\natexit.register(shutdown_observability)\n```\n\n## Solution\n\nUse `SimpleSpanProcessor` for CLI applications to ensure immediate export:\n\n```python\n# src/frigate_tools/cli.py:44\ninit_observability(sync_export=True)  # Force synchronous export for CLI\n```\n\n**Why this works:**\n- SimpleSpanProcessor exports spans immediately (synchronous)\n- BatchSpanProcessor batches for efficiency (async, good for long-running services)\n- CLI tools are short-lived, need immediate export\n- Long-running services benefit from batching, CLIs don't\n\n## Testing Plan\n\n1. **Verify traces reach Datadog**:\n   - [ ] Run timelapse command with fix applied\n   - [ ] Check Datadog agent logs for `service.name:frigate-tools`\n   - [ ] Verify traces appear in Datadog UI\n   - [ ] Confirm trace context in structured logs\n\n2. **Test trace content**:\n   - [ ] Verify span names match operation names\n   - [ ] Check attributes are present (file_count, duration, etc.)\n   - [ ] Confirm nested spans show parent/child relationships\n   - [ ] Validate timing information is accurate\n\n3. **Test both commands**:\n   - [ ] `frigate-tools timelapse create` - verify concat and encode spans\n   - [ ] `frigate-tools clip create` - verify clip creation spans\n   - [ ] Multi-camera operations - verify grid spans\n\n4. **Performance check**:\n   - [ ] Ensure synchronous export doesn't significantly slow down commands\n   - [ ] Verify no blocking on network issues (check timeout behavior)\n\n## Success Criteria\n\n- Traces from frigate-tools appear in Datadog APM\n- All operations (concat, encode, grid) are traced\n- Trace context properly injected into structured logs\n- No significant performance degradation\n- Error traces properly marked with error status\n\n## Related\n\nThis is a common pattern for OpenTelemetry CLI applications - see:\n- https://opentelemetry.io/docs/specs/otel/trace/sdk/#shutdown\n- https://github.com/open-telemetry/opentelemetry-python/issues/1718","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-07T10:11:40.563093817-05:00","updated_at":"2025-12-07T10:16:46.197382362-05:00","closed_at":"2025-12-07T10:16:46.197382362-05:00"}
{"id":"frigate-tools-vit","title":"CLI progress spinner shows wrong phase during timelapse creation","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-06T15:14:30.300509946-05:00","updated_at":"2025-12-06T15:16:13.257837593-05:00","closed_at":"2025-12-06T15:16:13.257837593-05:00"}
{"id":"frigate-tools-x9r","title":"Test infrastructure setup","description":"Set up pytest with fixtures for test data. Create mock Frigate directory structure for testing. Include sample video segments for integration tests. Ensure all modules have corresponding test files.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T13:58:42.785601436-05:00","updated_at":"2025-12-06T13:58:53.224417378-05:00","closed_at":"2025-12-06T13:58:53.224417378-05:00"}
{"id":"frigate-tools-xew","title":"Add integration test for timelapse encoding with real video files","description":"","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T14:56:18.313417083-05:00","updated_at":"2025-12-06T14:58:49.761438385-05:00","closed_at":"2025-12-06T14:58:49.761438385-05:00","dependencies":[{"issue_id":"frigate-tools-xew","depends_on_id":"frigate-tools-xla","type":"blocks","created_at":"2025-12-06T14:56:24.264486523-05:00","created_by":"daemon"}]}
{"id":"frigate-tools-xla","title":"Timelapse encoding too slow for large inputs - needs frame sampling","description":"Encoding 7 hours of footage (25GB concat file) to 60s timelapse took 13+ minutes and appeared stuck. The setpts filter requires decoding every frame of the source video, which is extremely slow for large inputs.\n\nOptions to fix:\n1. Add frame sampling (select every Nth frame) instead of setpts\n2. Use -r to set output framerate and let ffmpeg skip frames\n3. Add a 'select' filter: select='not(mod(n,420))' to only process 1 in 420 frames\n4. Add timeout/progress estimation to detect stuck encodes","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-06T14:53:17.894890294-05:00","updated_at":"2025-12-06T14:56:52.593192025-05:00","closed_at":"2025-12-06T14:56:52.593192025-05:00"}
{"id":"frigate-tools-xya","title":"Review timelapse.py progress callback stdout handling","description":"timelapse.py:213-216 reads from process.stdout in a loop then calls process.communicate(). This works because the iterator consumes the stream, but the pattern is fragile. If stdout isn't fully consumed before communicate(), it could hang. Consider using communicate() with timeout or restructuring to avoid potential race condition.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-06T14:19:51.872498548-05:00","updated_at":"2025-12-06T14:25:28.576180717-05:00","closed_at":"2025-12-06T14:25:28.576180717-05:00"}
{"id":"frigate-tools-yct","title":"Clip CLI interface","description":"frigate-tools clip --cameras bporchcam,frontcam --start 2025-12-01T12:00 --end 2025-12-01T12:05 --separate -o output.mp4. Also support --duration 5m as alternative to --end. Wire up file selection, concat, and grid modules.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-06T14:02:23.580546185-05:00","updated_at":"2025-12-06T14:23:56.820153989-05:00","closed_at":"2025-12-06T14:23:56.820153989-05:00","dependencies":[{"issue_id":"frigate-tools-yct","depends_on_id":"frigate-tools-2ip","type":"blocks","created_at":"2025-12-06T14:05:31.131690907-05:00","created_by":"daemon"}]}
